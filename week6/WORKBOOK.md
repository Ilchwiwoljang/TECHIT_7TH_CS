# DB 정규화

# 정규화 → ****Normalization****

정규화의 기본적인 개념은 테이블 간 중복된 데이터를 허용하지 않는다는 것.

중복된 데이터가 없을 경우 DB는 무결성을 유지할 수 있으며 DB의 저장 용량 역시 줄일 수 있다.

## 정규화 과정

1NF (제 1 정규화)

2NF (제 2 정규화)

3NF (제 3 정규화)

BCNF (보이스코드 정규화)

4NF (제 4 정규화)

5NF (제 5 정규화)

## 4NF와 5NF를 잘 사용하지 않는 이유

이 두개의 경우 특별한 상황에서만 적용이 되며 모든 상황에서 사용이 되지는 않는다.

### 4NF

다치종속을 해결하기 위해 사용됩니다.

다치 종속은 후보키가 여러개의 비 주요 속성들에 종속되는 상황을 나타낸다.

4NF를 사용하면 다치종속을 해결할 수 있지만 많은 경우에 복잡성이 증가하고 성능이 저하되는 문제가 발생한다.

### 다치 종속이란??

| 학생 | 수강과목 | 참여 스터디 |
| --- | --- | --- |
| 김태섭 | 자바, 스프링, JPA | 작심삼일스터디, 새벽반 스터디 |

제 1 정규형의 원칙인 컬럼은 하나의 속성만을 가져야한다. 를 적용하게 될 경우

| 학생 | 수강과목 | 참여 스터디 |
| --- | --- | --- |
| 김태섭 | 자바 | 작심삼일 스터디 |
| 김태섭 | 자바 | 새벽반 스터디 |
| 김태섭 | 스프링 | 작심삼일 스터디 |
| 김태섭 | 스프링 | 새벽반 스터디 |
| 김태섭 | JPA | 작심삼일 스터디 |
| 김태섭 | JPA | 새벽반 스터디 |

### 5NF

조인 종속성을 해결하기 위한 졍규형이다.

조인 종속성은 여러 테이블 간의 조인이 특정 조건을 만족할 때만 의미가 있는 상황을 나타낸다.

제5정규형을 적용하면 조인 종속성은 해결이 가능하지만 이는 매우 드믄 경우에만 필요로 하며

4NF와 동일하게 성능이 저하되는 문제가 발생한다.

## 제1 정규형 1NF

1. 각 컬럼이 하나의 속성만을 가져야 한다.

2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.

3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.

4. 칼럼의 순서가 상관없어야 한다.

아래 예시를 통해서 이야기를 해보자

| 수강생 번호 | 수강생 이름 | 강의 프로그램 |
| --- | --- | --- |
| 1 | 김태섭 | 자바 |
| 2 | 송낙원 | 스프링 |
| 3 | 이유진 | 스프링 |
| 4 | 차현경 | 스프링 |
| 5 | 홍지은 | 자바 |

이러한 데이터 테이블이 있다고 가정해보자

이 테이블에서 김태섭이 만약 “스프링” 교육을 듣는다고 한다면 데이터를 어떻게 추가할 것인가?

| 수강생 번호 | 수강생 이름 | 강의 프로그램 |
| --- | --- | --- |
| 1 | 김태섭 | 자바, 스프링 |
| 2 | 송낙원 | 스프링 |
| 3 | 이유진 | 스프링 |
| 4 | 차현경 | 스프링 |
| 5 | 홍지은 | 자바 |

이러한 경우 DB에서 스프링을 수강하는 학생을 찾기 위해서는

`SELECT * FROM member WHERE 강의프로그램 = ‘스프링’`

이 아닌

`SELECT * FROM member WHERE 강의프로그램 LIKE ’%스프링%’` 과 같은 sql을 작성해야한다.

이러한 경우 1정규형 규칙 중

1번인 각 컬럼이 하나의 속성만을 가져야 한다. 만족을 하지 못한다.

이를 해결하기 위해서는 아래와 같이 수정을 해야한다.

| 수강생 번호 | 수강생 이름 | 강의 프로그램 |
| --- | --- | --- |
| 1 | 김태섭 | 자바 |
| 1 | 김태섭 | 스프링 |
| 2 | 송낙원 | 스프링 |
| 3 | 이유진 | 스프링 |
| 4 | 차현경 | 스프링 |
| 5 | 홍지은 | 자바 |

이렇게 하나의 컬럼이 원자 값을 갖도록 분리를하면 제 1 정규형을 만족하게 바꿀 수 있다.

## 제 2정규형 2NF

1. 제 1정규형을 만족해야 한다.
2. 모든 컬럼이 부분적 종속이 없어야 한다. 즉, 모든 컬럼이 완전 함수 종속을 만족해야 한다.

제 2정규형 예시를 위해 컬럼을 추가해보도록 하자.

| 수강생 번호 | 수강생 이름 | 강의 프로그램 | 강사 |
| --- | --- | --- | --- |
| 1 | 김태섭 | 자바 | 남궁성 |
| 1 | 김태섭 | 스프링 | 김영한 |
| 2 | 송낙원 | 스프링 | 김영한 |
| 3 | 이유진 | 스프링 | 김영한 |
| 4 | 차현경 | 스프링 | 김영한 |
| 5 | 홍지은 | 자바 | 남궁성 |

이 테이블을 보고 만약 강의프로그램 중 자바의 강사를 수정하려면 어떻게해야하나?

강의 프로그램에서 자바 항목을 찾아 모든 강사를 수정해야할 것이다.

강사 한명을 수정하는 것이지만 강의프로그램에 종속되어 있는 강사를 모두 바꿔야하여 비효율적이다.

제 2 정규화는 간단하게 보면 현재 테이블의 주제와 관련없는 컬럼을 다른 테이블로 분리하는 작업이라고 생각하면 된다.

그럼 테이블을 분리해보자

| 수강생 번호 | 수강생 이름 | 강의 프로그램 |
| --- | --- | --- |
| 1 | 김태섭 | 자바 |
| 1 | 김태섭 | 스프링 |
| 2 | 송낙원 | 스프링 |
| 3 | 이유진 | 스프링 |
| 4 | 차현경 | 스프링 |
| 5 | 홍지은 | 자바 |

| 강의 프로그램 | 강사 |
| --- | --- |
| 자바 | 남궁성 |
| 스프링 | 김영한 |

이렇게 분리를 하게되면 자바 프로그램의 강사를 한번만 바꾸면 되고 수강생 테이블에서 자바 강사를 찾기 위해

join을 통해서 데이터를 조회할 수 있다.

조회하는 것은 다소 귀찮아졌지만 데이터를 수정하는 과정에서 반복적인 작업을 하지 않아도 된다.

## 제 3정규형 3NF

1. 제 2정규형을 만족해야 한다.
2. 기본키를 제외한 속성들간의 이행 종속성 (Transitive Dependency)이 없어야 한다.

| 강의 프로그램 | 강사 | 소속 회사 |
| --- | --- | --- |
| 자바 | 남궁성 | 섭컴퍼니 |
| 스프링 | 김영한 | 프리랜서 |

이 테이블을 보자 강의 프로그램이라는 pk 가 있다

강사는 강의프로그램 컬럼에 종속이 되지만

소속회사는 강사 컬럼에 종속이 된다.

제 3 정규형에서는 pk와 상관없는 컬럼을 다른 테이블로 분리하는 것이 제3정규형이다.

분리를 하게 되면 아래와 같은 테이블의 형태가 완성된다

| 강의 프로그램 | 강사 |
| --- | --- |
| 자바 | 남궁성 |
| 스프링 | 김영한 |

| 강사 | 소속 회사 |
| --- | --- |
| 남궁성 | 섭컴퍼니 |
| 김영한 | 프리랜서 |

제 3정규형은 일반 컬럼에 종속된 컬럼을 다른 테이블로 분리하는 것이라고 생각하면 된다.

## BCNF (보이스코드 정규화)

BCNF는 제 3 정규형을 조금 더 강화시킨 개념이다.

많은 경우에 제3 정규형까지 정규화를 하면 이상 현상을 거의 없앨 수 있습니다. 하지만, 조금 예외적인 상황에서는 제3 정규형에서도 이상 현상이 발생할 수 있고 이를 해결하기 위해 BCNF가 필요하죠.

아래의 테이블을 보자

| 수강생 이름 | 강의 프로그램 | 강사 |
| --- | --- | --- |
| 김태섭 | 자바 | 남궁성 |
| 송낙원 | 스프링 | 김영한 |
| 이유진 | 스프링 | 김영한 |

강사는 강의 프로그램에 따라 지정이 되고 한명의 강사는 반드시 하나의 강의 프로그램만 할 수 있다고 가정하자

그리고 수강생은 여러개의 강의를 들을 수 있다.

이 상황에서 강사를 알면 어떤 강의프로그램을 듣는지 알 수 있는 이상한 현상이 발생이 되고

만약 김태섭 수강생이 강의 정보를 삭제하게 된다면 남궁성 강사 또한 자바 프로그램을 담당하고 있다는 데이터가 사라질겁니다.

이러한 경우 모든 결정자가 후보키가 아니라는 것이다.

위 테이블을 bcnf로 분리하면 아래와 같이 분리를 할 수 있다.

| 수강생 이름 | 강의 프로그램 |
| --- | --- |
| 김태섭 | 자바 |
| 송낙원 | 스프링 |
| 이유진 | 스프링 |

| 강의 프로그램 | 강사 |
| --- | --- |
| 자바 | 남궁성 |
| 스프링 | 김영한 |
| 스프링 | 김영한 |

이렇게 되면 모든 결정자는 후보키가 되기 때문에 BCNF가 성립하게되고 더이상 이상현상이 발생하지 않는다.

# 정규화의 장단점

## 정규화 장점

- 데이터베이스 변경 시 이상 현상(Anomaly)을 제거할 수 있다.
- 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용프로그램의 생명을 연장시킨다.

## 정규화 단점

- 릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아진다.
- 질의에 대한 응답 시간이 느려질 수도 있다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다.
- 따라서 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다.
- 만약 조인이 많이 발생하여 성능 저하가 나타나면 반정규화(De-normalization)를 적용할 수도 있다.


# 정규화 정리

하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

### 제1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value; 하나의 값)을 갖도록 분해합니다.

### 제2 정규형: 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.
* 여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미

### 제3 정규형 : 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해합니다.
※ 여기서 이행적 종속이란 A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미

### BCNF 정규형 : 제3 정규형을 만족하고, 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.

## 역정규화는 뭔가요?
정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다. 역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.